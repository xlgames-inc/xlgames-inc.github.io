<?xml version="1.0"?>
<rss version="2.0">
  <channel>
    <title>XLE development blog</title>
    <description>XLE development blog</description>
    <link>http://xlgames-inc.github.io</link>
    <pubDate>January 22, 2016</pubDate>
    <item>
      <title>Transmission Node Diagram</title>
      <link>http://xlgames-inc.github.io/posts/transmissionnodegraph</link>
      <pubDate>January 22, 2016</pubDate>
      <description>&lt;p&gt;Here is a node diagram for the specular transmission function (BTDF) from Walter, et al, from &lt;em&gt;&amp;quot;Microfacet Models for Refraction through Rough Surfaces.&amp;quot;&lt;/em&gt;
Also known as the &amp;quot;GGX&amp;quot; model (or Trowbridge-Reitz).&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;img src="/assets/media/MaterialTool/WalterGGXTransmission.png"&gt;&lt;/p&gt;

&lt;p&gt;You can see how the node graph comes in handy for debugging a shader function like this. It&amp;#39;s useful to visualize each term and see it&amp;#39;s effects.
For example, the &amp;quot;D&amp;quot; term of the BTDF is a node on the diagram. And we can visualize the effects of that term independent of everything else.&lt;/p&gt;

&lt;p&gt;In this case, the diagram saves a HLSL function, and that function is called by text-based HLSL code. This will become part of some new functionality for specular transmission through thin surfaces.&lt;/p&gt;

&lt;p&gt;I&amp;#39;ll pop this in a new &amp;quot;experimental&amp;quot; branch.&lt;/p&gt;

&lt;p&gt;See the post from yesterday, &lt;a href="materialtool"&gt;Material and Node Diagram Tool&lt;/a&gt;, for more information.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Material and Node Diagram Tool</title>
      <link>http://xlgames-inc.github.io/posts/materialtool</link>
      <pubDate>January 21, 2016</pubDate>
      <description>&lt;p&gt;The master branch has just been updated! It now includes a major new tool, called the &lt;em&gt;MaterialTool&lt;/em&gt;. This is a dedicated app for building materials and applying them to objects, and includes some cool new features...&lt;/p&gt;

&lt;p&gt;In XLE, most material information can be authored in standard graphics packages (like 3DS Max, Maya, Substance Painter, etc). In particular, the most critical material values (&lt;strong&gt;color&lt;/strong&gt;, &lt;strong&gt;roughness&lt;/strong&gt;, &lt;strong&gt;specular&lt;/strong&gt; &amp;amp; &lt;strong&gt;metal&lt;/strong&gt;) can come directly from standard packages.&lt;/p&gt;

&lt;p&gt;But in cases we want to add custom information to models, or even develop custom shaders for complex materials. This is were the &lt;em&gt;MaterialTool&lt;/em&gt; comes in. There is some functionality in common with the &lt;em&gt;ModelViewer&lt;/em&gt; and &lt;em&gt;LevelEditor&lt;/em&gt; tools -- but the &lt;em&gt;MaterialTool&lt;/em&gt; provides a convenient focused tool for this kind of work.&lt;/p&gt;

&lt;hr&gt;

&lt;h2 id="toc_0"&gt;Basic functionality&lt;/h2&gt;

&lt;p&gt;&lt;br/&gt;&lt;img src="/assets/media/MaterialTool/BasicWindow.png"&gt;&lt;/p&gt;

&lt;p&gt;Our core functionality allows us to preview a model (much like the &lt;em&gt;ModelViewer&lt;/em&gt;, with various rendering modes), click on materials and then change their properties (such as opacity, translucency modes, and various shader flags).&lt;/p&gt;

&lt;p&gt;This works within the Sony ATF framework, and so we have all of the handy features from the &lt;em&gt;LevelEditor&lt;/em&gt;, such as:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;detachable, arrangeable windows&lt;/li&gt;
&lt;li&gt;&lt;em&gt;IronPython&lt;/em&gt; scripting and cvar access&lt;/li&gt;
&lt;li&gt;interface skinning, keyboard rebinding, etc...&lt;/li&gt;
&lt;li&gt;and, of course, it&amp;#39;s all very extensible C# code, convenient for adding custom features&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;h2 id="toc_1"&gt;Node Diagram editor&lt;/h2&gt;

&lt;p&gt;&lt;br/&gt;&lt;img src="/assets/media/MaterialTool/NodeDiagramEditor.png"&gt;&lt;/p&gt;

&lt;p&gt;Also integrated is a new version of the node diagram editor. This is used for building custom shaders for special cases.
Make it possible to visually create shader logic. It&amp;#39;s designed for use by both programmers and technical artists.&lt;/p&gt;

&lt;p&gt;Each diagram becomes a expression in HLSL shader code (and this can be used, just like any other shader). But these expressions can become very complex, and can (indirectly) include loops and conditions.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;img src="/assets/media/MaterialTool/DiagramCharts.png"&gt;&lt;/p&gt;

&lt;p&gt;Each node in the diagram has a real time preview. For mathematical nodes, this might be a &lt;strong&gt;chart&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;img src="/assets/media/MaterialTool/Preview3D.png"&gt;&lt;/p&gt;

&lt;p&gt;But we can also have &lt;strong&gt;3D previews&lt;/strong&gt; (using a sphere, box or a full model).&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;img src="/assets/media/MaterialTool/PreviewTexture.png"&gt;&lt;/p&gt;

&lt;p&gt;Texture nodes can also be previewed using a flat &lt;strong&gt;2D preview&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Previewing the diagram at every node makes the process of creating shaders much more visual. The effect of each function on the final shader becomes immediately apparent.&lt;/p&gt;

&lt;p&gt;For example, XLE has some shader code for converting a &amp;quot;&lt;em&gt;specular color&lt;/em&gt;&amp;quot; texture into the new &amp;quot;&lt;em&gt;roughness, specular, metal&lt;/em&gt;&amp;quot; scheme (for convenience reasons). Building this logic as a node diagram is infinitely easier than just working in raw &lt;em&gt;HLSL&lt;/em&gt; directly, because we can see the results immediately, and in detail.&lt;/p&gt;

&lt;hr&gt;

&lt;h2 id="toc_2"&gt;Nodes are HLSL functions!&lt;/h2&gt;

&lt;p&gt;So far, the node diagram tool sounds fairly standard. But there&amp;#39;s an important twist. A node diagram is just a collection of &amp;quot;nodes&amp;quot; that have been connected together. But where do those nodes come from, and what do they do?&lt;/p&gt;

&lt;p&gt;XLE contains a permissive &lt;em&gt;HLSL&lt;/em&gt; parser (written in &lt;em&gt;Antlr3&lt;/em&gt;). This parser can parse almost all valid &lt;em&gt;HLSL&lt;/em&gt; code and can build an abstract syntax tree of it&amp;#39;s contents. In particular, we can use this parser to extract the function signatures from a shader file.&lt;/p&gt;

&lt;p&gt;So, for example the shader file &lt;em&gt;Surface.h&lt;/em&gt; contains the functions &lt;em&gt;VSIn_GetLocalPosition&lt;/em&gt;, &lt;em&gt;VSIn_GetLocalTangent&lt;/em&gt;, etc... Our parser can read &lt;em&gt;Surface.h&lt;/em&gt; and find those functions, plus their parameters, output type, semantics, etc.&lt;/p&gt;

&lt;p&gt;So, there&amp;#39;s our answer! Our nodes are actually &lt;em&gt;HLSL&lt;/em&gt; functions. And since our parser works will every shader source file in XLE, that means that any shader function can be used as a node.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;img src="/assets/media/MaterialTool/ShaderFragmentPalette.png"&gt;&lt;/p&gt;

&lt;p&gt;Nodes are dragged into the diagram from something called the shader fragment palette.&lt;/p&gt;

&lt;p&gt;There are no hard coded nodes, and the shader fragment palette is reloaded on the fly. So, if you&amp;#39;re building a diagram and suddenly realize you want a new node type... Just open a text editor, add a new function into a shader file, and it can immediately be dragged into your diagram.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;xleres/Nodes&lt;/em&gt; directory is set aside to contain functions that are specifically intended to be used as nodes. In some cases, functions in this folder are just thin wrappers over other functions. But it&amp;#39;s recommended to mostly use functions from this directory in node diagrams, so as to isolate diagrams from shader changes.&lt;/p&gt;

&lt;hr&gt;

&lt;h2 id="toc_3"&gt;Each diagram is both a node type and a shader function&lt;/h2&gt;

&lt;p&gt;Use of HLSL as nodes creates some interesting advantages. Each diagram itself is a shader function. And so, when you save a diagram to disk, you can then use that diagram as a node in another diagram. In this way, we can have embedded diagrams very easily.&lt;/p&gt;

&lt;p&gt;It also means that we have full control over when to use a diagram, and when to use text-based HLSL. Some expressions are just awkward to do in diagram form.&lt;/p&gt;

&lt;p&gt;For example, try implementing a Modulo function as a diagram using just divide, multiply, subtract and round nodes. It can be done, but it&amp;#39;s awkward. In cases like this, it&amp;#39;s better to just write a text based function (in this case, using built-in shader language functions) and then use that function within your diagram.&lt;/p&gt;

&lt;hr&gt;

&lt;h2 id="toc_4"&gt;Complex shaders&lt;/h2&gt;

&lt;p&gt;&lt;br/&gt;&lt;img src="/assets/media/MaterialTool/ProceduralWood.png"&gt;&lt;/p&gt;

&lt;p&gt;These methods can be used to create arbitrarily complex shaders. Above is an example of a node diagram that was duplicated from the (CC-Zero) Cycles Material Library:
    &lt;a href="http://www.blendswap.com/blends/view/56470"&gt;http://www.blendswap.com/blends/view/56470&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This is a 100% procedural texture, with no texture inputs. The XLE implementation uses the same arrangements of nodes and the same constants to give the same final results as the Cycles render engine.&lt;/p&gt;

&lt;p&gt;Since the output is text &lt;em&gt;HLSL&lt;/em&gt; code, the normal &lt;em&gt;HLSL&lt;/em&gt; compiler and optimizers apply. There are certain cases in which hand written &lt;em&gt;HLSL&lt;/em&gt; code will be more efficient the diagram based stuff -- but that might be an advanced topic. In many cases, the diagram based shaders should be as efficient as hand written code.&lt;/p&gt;

&lt;hr&gt;

&lt;h2 id="toc_5"&gt;Using a diagram as a material&lt;/h2&gt;

&lt;p&gt;To use a diagram as an object material, follow these steps:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Create an output node from &lt;strong&gt;Nodes/Outputs.sh:Output_PerPixel&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;You may need some inputs from geometry, these are usually &amp;quot;Get&amp;quot; or &amp;quot;Sample&amp;quot; functions. For example, &lt;strong&gt;Nodes/Texture.sh:SampleTextureDiffuse&lt;/strong&gt;, and &lt;strong&gt;Surface.h:GetNormal&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;To create a material parameter, right click in empty space and select &amp;quot;Create Input&amp;quot;&lt;/li&gt;
&lt;li&gt;Go to &lt;em&gt;Edit/Diagram Settings...&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Select &amp;quot;Technique (material for any object)&amp;quot; as the diagram type&lt;/li&gt;
&lt;li&gt;Save your diagram! (you must save to see the results in the Model view window currently)&lt;/li&gt;
&lt;li&gt;Now you can go to the &amp;quot;Model view&amp;quot; window, right click an object and select &lt;em&gt;&amp;quot;Assign Technique (...)&amp;quot;&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Check out &lt;strong&gt;Working/Game/xleres/Objects/Basic.tech&lt;/strong&gt; as a starting example.&lt;/p&gt;

&lt;hr&gt;

&lt;h2 id="toc_6"&gt;Node graph dynamic linking&lt;/h2&gt;

&lt;p&gt;You may notice some similarity between this technology and a previous post -- &lt;a href="functionlinkedshaders"&gt;Dynamic Function Linking Graph for Shaders&lt;/a&gt;. They are similar because they both involve linking together the inputs and outputs of shader functions. But unfortunately they don&amp;#39;t work together yet... Perhaps later...?&lt;/p&gt;

&lt;hr&gt;

&lt;h2 id="toc_7"&gt;Other uses of the HLSL parser&lt;/h2&gt;

&lt;p&gt;The HLSL parser has some other cool applications... It can parse most valid HLSL code. And actually, it&amp;#39;s fairly permissive, so some invalid HLSL code will parse, as well.&lt;/p&gt;

&lt;p&gt;I&amp;#39;ve been using this parser as a linter for HLSL code in the Atom editor! There is a linter plugin for Atom, and so all it involved was creating a script that ran the &amp;quot;ShaderScan&amp;quot; sample. This reads HLSL code and spits out parsing errors.&lt;/p&gt;

&lt;p&gt;And so, those parsing errors now appear in real time while writing HLSL code in Atom. This has two uses for me, currently... It catches certain errors in the HLSL (Intellisense-style). But it&amp;#39;s also serving as a way to test the parser itself!&lt;/p&gt;

&lt;p&gt;In theory, this parser could also be extended to provide automatic conversion between HLSL and GLSL (or other languages). Some engines use this kind of approach for dealing with cross platform issues. Another possibility is just to use a complex series of #defines... But either method would be awkward in it&amp;#39;s own unique way.&lt;/p&gt;

&lt;hr&gt;

&lt;h2 id="toc_8"&gt;Support for other languages&lt;/h2&gt;

&lt;p&gt;Currently the node diagram tool is designed for use with HLSL. However, in theory it can also be used with other languages. All we need is a parser that can extract the function signatures. Since HLSL is a fairly generic c-like syntax, it shares a lot of similarity with many other languages. So the code that builds HLSL from the shader diagram could probably be easily adapted for languages (like Lua, Python, D, Swift, whatever).&lt;/p&gt;

&lt;p&gt;This could be handy because HLSL is tied to GPU execution only. But another language would open the door for CPU side execution -- which could be used for game logic, physics or any other systems. This would be handy, because it would mean reusing the same core node diagram functionality for multiple separate tasks.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Dynamic Function Linking Graph for Shaders</title>
      <link>http://xlgames-inc.github.io/posts/functionlinkedshaders</link>
      <pubDate>December 16, 2015</pubDate>
      <description>Stitching shaders together at runtime to deal with shader configuration explosion</description>
    </item>
    <item>
      <title>Rectangle Light diffuse vs 3DS Max</title>
      <link>http://xlgames-inc.github.io/posts/rectlightdiffuse</link>
      <pubDate>December 11, 2015</pubDate>
      <description>&lt;p&gt;Just a quick note on rectangle light diffuse. In XLE, rectangle lights are slightly different from the default rectangle lights in 3DS Max.&lt;/p&gt;

&lt;style type="text/css"&gt;
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}
.tg .tg-yw4l{vertical-align:top}
&lt;/style&gt;

&lt;table class="tg"&gt;
  &lt;tr&gt;
    &lt;th class="tg-yw4l"&gt;XLE lights&lt;/th&gt;
    &lt;th class="tg-yw4l"&gt;3DS Max lights (Quicksilver renderer)&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-yw4l"&gt;&lt;img src="/assets/media/RectLightDiffuse/XLELightDiag.png"&gt;&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;&lt;img src="/assets/media/RectLightDiffuse/MaxLightDiag.png"&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-yw4l"&gt;&lt;img src="/assets/media/RectLightDiffuse/XLEDefault.png"&gt;&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;&lt;img src="/assets/media/RectLightDiffuse/MaxComparison.png"&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;XLE rectangle lights emit light mostly in the forward direction (and a reduced amount sideways). But in the 3DS Max Quicksilver renderer, rectangle lights emit light in all direction.&lt;/p&gt;

&lt;h2 id="toc_0"&gt;Edge cases&lt;/h2&gt;

&lt;p&gt;This is partially because the method we&amp;#39;re using for diffuse doesn&amp;#39;t work well on extreme angles. In the above example, the light plane and the &lt;strong&gt;top&lt;/strong&gt;/&lt;strong&gt;bottom&lt;/strong&gt;/&lt;strong&gt;left&lt;/strong&gt;/&lt;strong&gt;right&lt;/strong&gt; walls are actually perpendicular.&lt;/p&gt;

&lt;p&gt;This causes weird problems right on the edges.&lt;/p&gt;

&lt;table class="tg"&gt;
  &lt;tr&gt;
    &lt;th class="tg-yw4l"&gt;XLE emulating 3DS Max&lt;/th&gt;
    &lt;th class="tg-yw4l"&gt;3DS Max lights (Quicksilver Renderer)&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-yw4l"&gt;&lt;img src="/assets/media/RectLightDiffuse/XLEEmulateMax.png"&gt;&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;&lt;img src="/assets/media/RectLightDiffuse/MaxComparison.png"&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;In the above example, the left and right walls look fine. But the top and bottom walls are missing their highlight. This is because the light is quite tall. A square light might be fine.&lt;/p&gt;

&lt;p&gt;But you can see that, in general, the 3DS Max result and the XLE result is quite similar.&lt;/p&gt;

&lt;h2 id="toc_1"&gt;Practical uses&lt;/h2&gt;

&lt;p&gt;It might be possible to fix this with some research and a few tricks. But it&amp;#39;s not clear if that would really be useful. Rectangle lights might be most useful for things like windows, TV screens, photography reflectors, etc. In these cases we normally want the light to always go forward, anyway.&lt;/p&gt;

&lt;p&gt;Plus, if we block off the extreme edges, we have some easy options for shadowing.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Working some improvements to rectangle lights</title>
      <link>http://xlgames-inc.github.io/posts/workingonrectlights</link>
      <pubDate>December 09, 2015</pubDate>
      <description>&lt;p&gt;&lt;strong&gt;Post updated on 2015-12-10&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This is just some notes about some ideas I&amp;#39;ve been playing with lately. I&amp;#39;ve been thinking about some improvements to the specular highlights for rectangle lights!&lt;/p&gt;

&lt;p&gt;The current implementation is based on the method by &lt;em&gt;Michal Drobot&lt;/em&gt; in &lt;strong&gt;GPU Pro 5&lt;/strong&gt;. I&amp;#39;m not going to repeat the description here (I&amp;#39;ll only give a few details) -- but I recommend buying the book and having a look! It&amp;#39;s quite a good method, and interesting read. Drobot describes a very practical method for diffuse and specular for rectangle and disc lights.&lt;/p&gt;

&lt;p&gt;However, at extreme angles, the specular reflection of rectangle lights can sometimes show some distortion.&lt;/p&gt;

&lt;p&gt;Here is a comparison:
&lt;style type="text/css"&gt;
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}
.tg .tg-yw4l{vertical-align:top}
&lt;/style&gt;
&lt;table class="tg"&gt;
  &lt;tr&gt;
    &lt;th class="tg-yw4l"&gt;Original Method&lt;/th&gt;
    &lt;th class="tg-yw4l"&gt;New Method&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-yw4l"&gt;&lt;img src="/assets/media/RectLightImprovements/BasicRectLight.png"&gt;&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;&lt;img src="/assets/media/RectLightImprovements/ImprovedRectLight.png"&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;p&gt;It appears quite distorted here, but this is a contrived example. This is a material with high &amp;quot;roughness&amp;quot; but the geometry is completely flat. In a normal scene, flat geometry will probably have a less rough material. And in a less rough material, the distortion is much less visible.&lt;/p&gt;

&lt;h2 id="toc_0"&gt;Specular Cone&lt;/h2&gt;

&lt;p&gt;Part of the problem is related to how the integration across the specular highlight is performed. We can calculate a cone that represents the part of the scene that contributes most greatly to the specular for a given point. When calculating the specular for a point, we assume that everything in that cone contributes very strongly to specular, and everything outside of it doesn&amp;#39;t contribute at all.&lt;/p&gt;

&lt;p&gt;This is a simplification, because really we don&amp;#39;t want a binary on/off -- we want to weight all incoming light by the BRDF. But out simplification can be quite good for many cases.&lt;/p&gt;

&lt;h2 id="toc_1"&gt;Rectangle and cone intersection&lt;/h2&gt;

&lt;p&gt;So, once we have our cone, we want to find how much of it is covered by the rectangle light. Ignoring shadows, we can do this by finding the intersection of the cone and the rectangle light.&lt;/p&gt;

&lt;p&gt;But, of course, this is quite difficult and expensive. This is starting to go into conic sections, which are a particularly complication type of geometry.&lt;/p&gt;

&lt;p&gt;So we need a simplification. Drobot describes a method that is very similar to his method for disc lights.&lt;/p&gt;

&lt;p&gt;His method treats the intersection between a plane and the cone as a circle, and then further simplifies it into a square. This method works really well when the light direction is directly towards to the sample point. But on angles, the intersection should start to distort into an ellipse.&lt;/p&gt;

&lt;p&gt;See, for example, this diagram from wikimedia commons:
&lt;br/&gt;&lt;a title="By http://commons.wikimedia.org/wiki/User:Magister_Mathematicae [CC BY-SA 3.0 (http://creativecommons.org/licenses/by-sa/3.0)], via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File%3AConic_sections_small.png"&gt;&lt;img width="256" alt="Conic sections small" src="https://upload.wikimedia.org/wikipedia/commons/b/bf/Conic_sections_small.png"/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We don&amp;#39;t have to care about the parabola or hyberbola cases (because our cone is infinitely long).&lt;/p&gt;

&lt;h2 id="toc_2"&gt;Ellipse estimations&lt;/h2&gt;

&lt;p&gt;Our goal is to find some way to estimate the area of an intersection of that ellipse and a rectangle. And we also need to find the geometric center of that intersection.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;img src="/assets/media/RectLightImprovements/LightGeoClipping.png"&gt;&lt;/p&gt;

&lt;p&gt;Working with the true ellipse here is far too expensive. The method would be extremely complex. However, we can make some estimations. Also, the rectangle and the ellipse are not aligned in any easy way -- so that makes it more complex.&lt;/p&gt;

&lt;p&gt;One idea is to use 2 squares, instead of one. We will place the squares near the vertices of the of the ellipse, and balance the area of the squares so that they roughly match the ellipse.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;img src="/assets/media/RectLightImprovements/LightGeoClipping2.png"&gt;&lt;/p&gt;

&lt;p&gt;With this method, as the ellipse widens, our simulation takes into account that widening.&lt;/p&gt;

&lt;h2 id="toc_3"&gt;Flat on&lt;/h2&gt;

&lt;p&gt;2 squares seems to help in the flat-on case, also.&lt;/p&gt;

&lt;table class="tg"&gt;
  &lt;tr&gt;
    &lt;th class="tg-yw4l"&gt;Original Method&lt;/th&gt;
    &lt;th class="tg-yw4l"&gt;New Method&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-yw4l"&gt;&lt;img src="/assets/media/RectLightImprovements/BasicRectLight2.png"&gt;&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;&lt;img src="/assets/media/RectLightImprovements/ImprovedRectLight2.png"&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;As you can see, improved method helps smooth out the result. The light retains it&amp;#39;s rectangular shape better.&lt;/p&gt;

&lt;h2 id="toc_4"&gt;Representative point tweaks&lt;/h2&gt;

&lt;p&gt;The goal of these methods is to find a quick estimate to integrating the BRDF across all angles. When we&amp;#39;re finding the intersection of the specular cone and the light, we&amp;#39;re really trying to estimate the intersection of the light geometry and the BRDF equation. If we could then find the mean of the BRDF in the intersection area, we would have a good estimate of the full integral.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;img src="/assets/media/RectLightImprovements/LightGeoClipping3.png"&gt;&lt;/p&gt;

&lt;p&gt;To estimate the mean, we adjust the reflection direction to find a new &amp;quot;representative point&amp;quot; for specular. As Drobot explains in his article, he was working with a phong based BRDF. However, with GGX, I&amp;#39;m finding the equation is very steep, and that small adjustments to the representative point have a huge effect on the result!&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;img src="/assets/media/RectLightImprovements/LightGeoClipping4.png"&gt;&lt;/p&gt;

&lt;p&gt;This might be accentuated by the fact that I&amp;#39;m using a very wide angle for the specular cone. The wide angle helps give us really blurry highlights, but it makes some artifact worse.&lt;/p&gt;

&lt;p&gt;So I&amp;#39;m finding that we have to be a little more conservative with the representative point. I&amp;#39;m experimenting with taking the average of the intersection center and the unmodified reflection direction.&lt;/p&gt;

&lt;h2 id="toc_5"&gt;New artifacts&lt;/h2&gt;

&lt;p&gt;Unfortunately, the new method can add some artifacts. Sometimes the influence of each square can separate, which can end up giving the impression of 2 separate specular highlights. This can cause some real problems if one square clipped by one side of the light, and the other square is clipped by the other side.&lt;/p&gt;

&lt;p&gt;There are also some cases where the single-square method looks better, even though it may be incorrect... With a single square, the highlight will be incorrectly sharp on extreme angles. But it still looks right to the viewer.&lt;/p&gt;

&lt;p&gt;Here is an example of the artifacts that can occur in some cases&lt;/p&gt;

&lt;table class="tg"&gt;
  &lt;tr&gt;
    &lt;th class="tg-yw4l"&gt;Original Method&lt;/th&gt;
    &lt;th class="tg-yw4l"&gt;New Method&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-yw4l"&gt;&lt;img src="/assets/media/RectLightImprovements/BasicRectLightBad1.png"&gt;&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;&lt;img src="/assets/media/RectLightImprovements/ImprovedRectLightBad1.png"&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;Here the rectangle keeps it&amp;#39;s shape better, but the separate effects of the 2 squares starts to become visible.&lt;/p&gt;

&lt;p&gt;In a real world situation, this is unlikely to be as visible. Since this is a surface with a high &amp;quot;roughness&amp;quot; we would normally expect there to be a normal map and more geometric detail. That will serve to hide the artifacts.&lt;/p&gt;

&lt;h2 id="toc_6"&gt;More screenshots&lt;/h2&gt;

&lt;p&gt;Here are a few more comparison shots:&lt;/p&gt;

&lt;p&gt;&lt;/style&gt;
&lt;table class="tg"&gt;
  &lt;tr&gt;
    &lt;th class="tg-yw4l"&gt;Original Method&lt;/th&gt;
    &lt;th class="tg-yw4l"&gt;New Method&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-yw4l"&gt;&lt;img src="/assets/media/RectLightImprovements/BasicRectLight3.png"&gt;&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;&lt;img src="/assets/media/RectLightImprovements/ImprovedRectLight3.png"&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-yw4l"&gt;&lt;img src="/assets/media/RectLightImprovements/BasicRectLight4.png"&gt;&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;&lt;img src="/assets/media/RectLightImprovements/ImprovedRectLight4.png"&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;h2 id="toc_7"&gt;In-engine visualization&lt;/h2&gt;

&lt;p&gt;You can use the cvar &amp;quot;LightResolveDebugging&amp;quot; to visualize the squares, intersection ellipse and representative points. Type &amp;quot;cv.LightResolveDebugging = True&amp;quot; in the IronPython window in the editor.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;img src="/assets/media/RectLightImprovements/Visualization.png"&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>What to do first</title>
      <link>http://xlgames-inc.github.io/posts/whattodofirst</link>
      <pubDate>December 04, 2015</pubDate>
      <description>&lt;p&gt;So, you&amp;#39;ve just downloaded XLE, and you&amp;#39;re wondering what to do first? Here&amp;#39;s a suggestion for the first 10 minutes:&lt;/p&gt;

&lt;hr&gt;

&lt;h2 id="toc_0"&gt;Startup the level editor&lt;/h2&gt;

&lt;p&gt;Select the Level Editor as the startup project:
&lt;br/&gt;&lt;img src="/assets/media/SolutionExplorerLE.png"&gt;&lt;/p&gt;

&lt;p&gt;You should use the &lt;strong&gt;Debug/x64&lt;/strong&gt; or &lt;strong&gt;Release/x64&lt;/strong&gt; configuration. Though XLE works in both 32 bit and 64 bits modes, normal usage for the level editor should be in 64 bits mode.&lt;/p&gt;

&lt;p&gt;If you have trouble compiling, see the &lt;a href="https://github.com/xlgames-inc/XLE/wiki/CompilingFirstSteps"&gt;Getting Started Compiling page&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Start up this application, and you should see a large 3D window and various other windows about.&lt;/p&gt;

&lt;p&gt;The level editor is based on a great project from Sony WWS &lt;a href="https://github.com/SonyWWS/LevelEditor"&gt;SonyWWSLevelEditor&lt;/a&gt;.
It has been modified to work with XLE, and some XLE specific behaviour has been added. I think this is a great example of the Open Source concept working for games developers.&lt;/p&gt;

&lt;hr&gt;

&lt;h2 id="toc_1"&gt;Creating an object&lt;/h2&gt;

&lt;p&gt;For the first minute, the 3D window will appear black. This is because shaders are compiling in the background. They will get flushed to disk on application shutdown, so it only happens the first time.&lt;/p&gt;

&lt;p&gt;Select &lt;em&gt;&amp;quot;Window/Resources&amp;quot;&lt;/em&gt; to open the resources panel. You should see the directory structure under the &amp;quot;working&amp;quot; folder. Here, you can find &lt;strong&gt;.dae&lt;/strong&gt; (Collada) files.&lt;/p&gt;

&lt;p&gt;Find a dae file, and drag it into the 3D viewport (or you can drag from Windows Explorer).&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;img src="/assets/media/DesignView.png"&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id="toc_2"&gt;Collada notes&lt;/h3&gt;

&lt;p&gt;XLE should support all well formatted Collada files. But unfortunately some exporters produce poorly formatted files. For example, sometimes texture names are prefixed with &lt;em&gt;&amp;quot;file://&amp;quot;&lt;/em&gt; -- this isn&amp;#39;t supported in XLE.&lt;/p&gt;

&lt;p&gt;But you should be fine with the Blender Collada exporter, or the OpenCollada exporter for Max/Maya. You can also use &lt;a href="http://www.assimp.org/"&gt;Open Asset Import Library&lt;/a&gt; to convert files to Collada format.&lt;/p&gt;

&lt;h3 id="toc_3"&gt;Placement documents&lt;/h3&gt;

&lt;p&gt;In the level editor, the main &amp;quot;game&amp;quot; file is like a solution file in Visual Studio. It contains links to project documents under it. One type of document is a &amp;quot;placements&amp;quot; document (called a &lt;em&gt;placements cell&lt;/em&gt;). This contains a list of static objects with basic properties.&lt;/p&gt;

&lt;p&gt;Normal large world games should have many placement cells. These can be arranged in a grid structure. But cells can also be overlapping, or have irregular shapes.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;img src="/assets/media/DefaultPlacementCell.png"&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;When you first startup the Level Editor, you get a default untitled placements document. However, you can reconfigure it by right-clicking &amp;quot;Placements&amp;quot; in the Project Lister and selecting &amp;quot;Configure placements...&amp;quot;&lt;/p&gt;

&lt;hr&gt;

&lt;h2 id="toc_4"&gt;Adding lighting settings&lt;/h2&gt;

&lt;p&gt;Probably, you will want to play with some lighting settings next.&lt;/p&gt;

&lt;p&gt;First, Find the &amp;quot;Palette&amp;quot; window (select &amp;quot;Window/Palette&amp;quot; to enable it if it isn&amp;#39;t visible).&lt;/p&gt;

&lt;p&gt;Here, open up the &amp;quot;Lights&amp;quot; category. You can drag items from the &amp;quot;Palette&amp;quot; window into the &amp;quot;Project Lister&amp;quot;.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;img src="/assets/media/PaletteWindow.png"&gt;&lt;/p&gt;

&lt;p&gt;Drag these 4 items from the &amp;quot;Lights&amp;quot; category of the &amp;quot;Palette&amp;quot; into the &amp;quot;Project Lister&amp;quot;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DirLight&lt;/li&gt;
&lt;li&gt;AreaLight&lt;/li&gt;
&lt;li&gt;AmbientSettings&lt;/li&gt;
&lt;li&gt;ToneMapSettings&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Try selecting the newly created &amp;quot;DirLight&amp;quot; in the Project Lister. You can press &amp;quot;M&amp;quot; to enable the &amp;quot;move&amp;quot; manipulator to move it around.&lt;/p&gt;

&lt;p&gt;Now, find the &amp;quot;Property Editor&amp;quot; window (select &amp;quot;Window/Property Editor&amp;quot; if it is hidden).
Here you can see all of the properties for the item. You can customize the lighting environment by playing with the settings for the 4 items you created.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;img src="/assets/media/PropertyEditor.png"&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;h2 id="toc_5"&gt;Console debugging modes&lt;/h2&gt;

&lt;p&gt;Next, find the &amp;quot;IronPython&amp;quot; window (use Window/Iron Python to enable it if it is hidden).&lt;/p&gt;

&lt;p&gt;Try typing &lt;strong&gt;&amp;quot;cv.DeferredDebugging = 1&amp;quot;&lt;/strong&gt;. This will enable a debugging mode. You can type &lt;strong&gt;&amp;quot;cv.DeferredDebugging = 0&amp;quot;&lt;/strong&gt; to disable it again.&lt;/p&gt;

&lt;p&gt;Here, &amp;quot;cv&amp;quot; stands for &lt;em&gt;&amp;quot;console variable&amp;quot;&lt;/em&gt;.&lt;/p&gt;

&lt;hr&gt;

&lt;h2 id="toc_6"&gt;What about the next 10 minutes?&lt;/h2&gt;

&lt;p&gt;Well, that&amp;#39;s the end of the quick introduction. The rest is up to you. Have fun!&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Area Lights with Physically Based Rendering</title>
      <link>http://xlgames-inc.github.io/posts/arealightsandpbr</link>
      <pubDate>December 02, 2015</pubDate>
      <description>&lt;p&gt;XLE now support a few area light types: &lt;em&gt;sphere&lt;/em&gt;, &lt;em&gt;tube&lt;/em&gt; &amp;amp; &lt;em&gt;rectangle&lt;/em&gt; (with &lt;em&gt;disc&lt;/em&gt; and maybe some other shapes coming soon). Maybe in a future post I&amp;#39;ll go into some details about the implementation (actually, it&amp;#39;s quite interesting!). But this post is about something different: this post is about why they are important.&lt;/p&gt;

&lt;p&gt;I&amp;#39;m finding that it makes a huge difference. So much so that not only do we want to support area lights -- we also want to outlaw non-area lights. Point light sources are now the enemy!&lt;/p&gt;

&lt;h2 id="toc_0"&gt;PBR Concept&lt;/h2&gt;

&lt;p&gt;The biggest buzzword at the moment is Physically Based Renderering (or PBR, or sometimes Physically Based Shading). But what does that mean, really?
Partially it means sampling values from the real world. But really it&amp;#39;s just a container under which we&amp;#39;re placing many related concepts.&lt;/p&gt;

&lt;p&gt;One of these &amp;quot;sub-concepts&amp;quot; of PBR is the idea that a single material should work in many different lighting environments.&lt;/p&gt;

&lt;p&gt;In the past, artists often tweaked the material settings for objects to suit the lighting environment they are in. This is a problem because it means that if the object moves into another lighting environment, the material settings must be tweaked to match.&lt;/p&gt;

&lt;p&gt;This happen in both movies and games. In games, it&amp;#39;s particularly a problem for games with a day/night cycle. In games where time is changing, the lighting environment is also always changing. Previously this means that extreme lighting settings (sunsets, etc) had to be more subtle than real-life. What we want is materials that look correct in all possible lighting environments.&lt;/p&gt;

&lt;h2 id="toc_1"&gt;Specular highlight size&lt;/h2&gt;

&lt;p&gt;There&amp;#39;s a simple way to think about this. Let&amp;#39;s consider the size of a specular highlight.&lt;/p&gt;

&lt;p&gt;Here are 5 spheres rendered in Blender with Cook Torrence lighting.
&lt;img src="/assets/media/SpecularExample.png"&gt;&lt;/p&gt;

&lt;p&gt;Each sphere is reflecting the same light, but the material settings are changed to change the size of highlight in each sphere.&lt;/p&gt;

&lt;p&gt;In older games, this was the only way to change the size of the highlight. If a highlight appeared too small or too big, an artist would change the material settings.&lt;/p&gt;

&lt;p&gt;However there should be something else that should effect the size of the highlight: obviously, it&amp;#39;s the shape of the light! We need area lights to achieve that.&lt;/p&gt;

&lt;h2 id="toc_2"&gt;New model for specular highlights&lt;/h2&gt;

&lt;p&gt;So, we have two important concepts to control the size of the specular highlights:
- &lt;strong&gt;material roughness&lt;/strong&gt;
- &lt;strong&gt;light size&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Notice that these ideas are simpler and clearer than concepts in older engines. Previously we might talk about &lt;em&gt;&amp;quot;gloss&amp;quot;&lt;/em&gt; or &lt;em&gt;&amp;quot;specular power&amp;quot;&lt;/em&gt; or &lt;em&gt;&amp;quot;specular hardness.&amp;quot;&lt;/em&gt; But what do those really mean?&lt;/p&gt;

&lt;p&gt;Roughness is much clearer. It&amp;#39;s just a single value between 0 and 1. And it&amp;#39;s linear -- not exponential! It&amp;#39;s probably the most important variable of our material model (other than Color, I guess).&lt;/p&gt;

&lt;h3 id="toc_3"&gt;Roughness&lt;/h3&gt;

&lt;p&gt;Roughness controls the size of the highlight by spreading the light energy over a large area.&lt;/p&gt;

&lt;p&gt;Notice the image above. In one extreme the highlight is a dense, concentrated point of light. In the other extreme, the specular light energy is spread out over a very large area, so that it appear almost like diffuse lighting.&lt;/p&gt;

&lt;p&gt;This is critical for us because in XLE, all materials are reflective. But when the roughness is very high, the reflections get spread out over a very large area, so that they appear almost diffuse.&lt;/p&gt;

&lt;p&gt;Also, both specular highlights and IBL reflections get spread out in the same way. Sometimes it&amp;#39;s even difficult to tell what is a specular highlight, and what is a reflection.&lt;/p&gt;

&lt;h3 id="toc_4"&gt;Light size&lt;/h3&gt;

&lt;p&gt;With rectangle and sphere lights, the size of the highlight will change significantly with the size of the light (and also the distance to the light). But it changes in a very different way to roughness. Large lights give an appearance that just wasn&amp;#39;t possible previously.&lt;/p&gt;

&lt;p&gt;If we want to make a very large specular highlight, we can do that by changing the size of the light. So there is no need to tweak the material any more!&lt;/p&gt;

&lt;h2 id="toc_5"&gt;No more point lights&lt;/h2&gt;

&lt;p&gt;Now, the only problem with this is point lights no longer look correct. If the material is balanced correctly for use with area lights, then highlights from point lights will look unnaturally too small. This is logical, because point light sources don&amp;#39;t exist in reality.&lt;/p&gt;

&lt;p&gt;Fortunately, sphere lights are only slightly more expensive than point lights. And we can use the same BRDFs with sphere lights. So it&amp;#39;s an easy transition.&lt;/p&gt;

&lt;p&gt;So the solution is to always use area lights, and never use point lights.&lt;/p&gt;

&lt;h2 id="toc_6"&gt;Authoring material settings&lt;/h2&gt;

&lt;p&gt;Even though we&amp;#39;ve created a separation between material settings and lighting environment settings, I&amp;#39;m still finding that we will probably need some kind of standard lighting environment for authoring the material settings.&lt;/p&gt;

&lt;p&gt;That is, the values that artists will select for roughness may vary with the lighting environment they are testing with.&lt;/p&gt;

&lt;p&gt;Probably an &lt;em&gt;Image Based Lighting&lt;/em&gt; environment would be best for this. This is a great reason why BRDF for IBL and dynamic lights should match as closely as possible. We should author the material settings in a 100% IBL environment, and then we should expect that dynamic lights should just work.&lt;/p&gt;

&lt;h2 id="toc_7"&gt;Simpler... and better&lt;/h2&gt;

&lt;p&gt;So, I found that area lights are critical to the PBR concept. So much so that an engine that doesn&amp;#39;t support area lights shouldn&amp;#39;t properly be called PBR.&lt;/p&gt;

&lt;p&gt;And I think it meets two important concepts of PBR:
- materials should look correct in all lighting environments
- it should be simpler and better (at the same time)&lt;/p&gt;

&lt;p&gt;3 cheers for area lights!&lt;/p&gt;
</description>
    </item>
    <item>
      <title>First post</title>
      <link>http://xlgames-inc.github.io/posts/first</link>
      <pubDate>December 01, 2015</pubDate>
      <description>&lt;p&gt;This blog will contain some day-to-day information about XLE.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s start with some screenshots, rendered with XLE:&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/media/CaptainSplitBrightLogo.png"&gt;&lt;br&gt;
The Captain character from &lt;a href="http://archeage.xlgames.com/"&gt;Archeage&lt;/a&gt; (&lt;a href="http://www.trionworlds.com/archeage/en/"&gt;US site&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/media/Archepunk4.png"&gt;&lt;br&gt;
One of the (many) costumes from Archeage.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/media/SkeleCommander.png"&gt;&lt;br&gt;
A skeleton enemy from Archeage.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/media/Copperhead1.png"&gt;&lt;br&gt;
A military spacecraft.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/media/gweonid4.png"&gt;&lt;br&gt;
The &amp;quot;Gweonid&amp;quot; character from Archeage.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/media/MetalGolem0.png"&gt;&lt;br&gt;
A metal golem character from Archeage.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/media/NyraAndDragon1.png"&gt;&lt;br&gt;
One of the costumes from Archeage, and &amp;quot;Nyra&amp;quot; character.
Nyra model comes from &lt;a href="http://www.paultosca.com/"&gt;Paul Tosca&lt;/a&gt;. Thanks for the great model, Paul!&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/media/Nyra9.png"&gt;&lt;br&gt;
Detail of Nyra&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/media/Nyra10.png"&gt;&lt;br&gt;
One more from Nyra.&lt;/p&gt;

&lt;p&gt;Many of the backgrounds in these images are from &lt;a href="http://www.hdrlabs.com/sibl/archive.html"&gt;sIBL Archive&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
  </channel>
</rss>
